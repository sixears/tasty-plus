{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE LambdaCase            #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE QuasiQuotes           #-}
{-# LANGUAGE RecordWildCards       #-}
{-# LANGUAGE PartialTypeSignatures #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TypeApplications      #-}
{-# LANGUAGE TypeFamilies          #-}
{-# LANGUAGE UnicodeSyntax         #-}
{-# LANGUAGE ViewPatterns          #-}

{- |

Description: utility functions for working with Tasty testing

-}

module TastyPlus
  ( TastyOpts( TastyOpts ), TastyRunResult(..)

  , (#?=), (#=?), (‚â£), (‚âü)

  , optParser, tastyOptParser

  , assertAnyException, assertAnyExceptionIO
  , assertCmp'
  , assertException, assertExceptionIO
  , assertIOException, assertIOException'
  , assertIsLeft, assertLeft, assertRight
  , assertListCmp, assertListCmpIO
  , assertListEq, assertListEqIO, assertListEqIO'
  , assertListEq', assertListEqR, assertListEqR', assertListEqRS
  , assertListEqS
  , assertSuccess

  , ioTests, mainTests

  , propAssociative
  , propInvertibleString, propInvertibleText, propInvertibleUtf8

  , runTests, runTests_, runTestsP, runTestsP_, runTestTree, runTestTree'
  , runTestsReplay

  , withResource', withResourceCleanup, withResource2, withResource2'

  -- for testing this module
  , tests
  )
where

import Prelude  ( (*), fromIntegral )

-- base --------------------------------

import Control.Applicative     ( (<*>) )
import Control.Exception       ( SomeException, evaluate, handle, onException )
import Control.Monad           ( (>>=), return )
import Control.Monad.IO.Class  ( MonadIO, liftIO )
import Data.Bool               ( Bool( True ), bool )
import Data.Either             ( Either( Left, Right ) )
import Data.Eq                 ( Eq )
import Data.Foldable           ( Foldable, concatMap, length, toList )
import Data.Function           ( ($), const, flip )
import Data.Functor            ( (<$>), fmap )
import Data.Int                ( Int )
import Data.List               ( intercalate, zip, zipWith3 )
import Data.Maybe              ( Maybe( Just, Nothing ), fromMaybe  )
import Data.Monoid             ( (<>), mempty )
import Data.Ratio              ( Rational )
import Data.String             ( String )
import GHC.Stack               ( HasCallStack )
import Numeric.Natural         ( Natural )
import System.Exit             ( ExitCode( ExitFailure, ExitSuccess ) )
import System.IO               ( IO )
import Text.Show               ( Show( show ) )

-- base-unicode-symbols ----------------

import Data.Eq.Unicode        ( (‚â°) )
import Data.Function.Unicode  ( (‚àò) )
import Data.Monoid.Unicode    ( (‚äï) )

-- data-textual ------------------------

import Data.Textual  ( Parsed( Parsed, Malformed ), Printable( print ), Textual
                     , parseString, parseText, parseUtf8, toString, toText
                     , toUtf8
                     )

-- deepseq -----------------------------

import Control.DeepSeq  ( NFData, force )

-- exited ------------------------------

import Exited  ( Exited( Exited ), doMain', exitWith )

-- monaderror-io -----------------------

import MonadError.IO        ( asIOError )
import MonadError.IO.Error  ( AsIOError, IOError )

-- more-unicode ------------------------

import Data.MoreUnicode.Bool     ( ùîπ )
import Data.MoreUnicode.Functor  ( (‚ä≥) )
import Data.MoreUnicode.Monad    ( (‚â´) )

-- mtl ---------------------------------

import Control.Monad.Except  ( runExceptT )

-- optparse-applicative ----------------

import Options.Applicative.Builder  ( failureCode, fullDesc, info, prefs
                                    , progDesc, showHelpOnError )
import Options.Applicative.Extra    ( customExecParser, helper )
import Options.Applicative.Types    ( Parser )

-- safe --------------------------------

import Safe  ( atMay )

-- tasty -------------------------------

import Test.Tasty          ( TestName, TestTree
                           , defaultIngredients, testGroup, withResource )
import Test.Tasty.Options  ( OptionSet )
import Test.Tasty.Runners  ( TestPattern, suiteOptionParser, tryIngredients )
import Test.Tasty.Options  ( singleOption )
import Test.Tasty.Runners  ( parseTestPattern )

-- tasty-hunit -------------------------

import Test.Tasty.HUnit  ( Assertion
                         , (@=?), (@?=), assertBool, assertFailure, testCase )

-- tasty-quickcheck --------------------

import Test.Tasty.QuickCheck  ( Property, QuickCheckReplay( QuickCheckReplay )
                              , (===), testProperty )

-- text --------------------------------

import Data.Text  ( Text, pack )

-- text-printer ------------------------

import qualified  Text.Printer  as  P

-------------------------------------------------------------------------------

-- | we need to provide a test tree to the optparser, anrd also to runTests;
--   to ensure consistency we encompass them in a single TastyOpts datum

data TastyOpts = TastyOpts { testTree ‚à∑ TestTree, optSet ‚à∑ OptionSet }

------------------------------------------------------------

data TastyRunResult = TestSuccess | TestsFailed | TestRunFailure
  deriving (Eq, Show)

rrExitCode ‚à∑ TastyRunResult ‚Üí ExitCode
rrExitCode TestSuccess    = ExitSuccess
rrExitCode TestsFailed    = ExitFailure 1
rrExitCode TestRunFailure = ExitFailure 2

------------------------------------------------------------

newtype ShowEqPrintable Œ± = ShowEqPrintable Œ±
  deriving Eq

instance Printable Œ± ‚áí Show (ShowEqPrintable Œ±) where
  show (ShowEqPrintable a) = toString a

{- | Pronounced 'test', this tests for equality; it's a variant of `(@=?)` that
     uses `Printable` rather than `Show` for error messages; note that the 'got'
     or 'actual' value is the last argument, to allow for easier partial
     application.
 -}
infix 1 ‚âü
(‚âü) ‚à∑ (Eq Œ±, Printable Œ±) ‚áí Œ± ‚Üí Œ± ‚Üí Assertion
x ‚âü y = ShowEqPrintable x @=? ShowEqPrintable y

----------------------------------------

{- | Almost-synonym for `===`, but using `Printable` instead of `Show`. -}
infix 4 ‚â£
(‚â£) ‚à∑ (Eq Œ±, Printable Œ±) ‚áí Œ± ‚Üí Œ± ‚Üí Property
x ‚â£ y = ShowEqPrintable x === ShowEqPrintable y

----------------------------------------

{- | Unconditionally signals success. -}
assertSuccess ‚à∑ Text ‚Üí Assertion
assertSuccess t = assertBool (toString t) True

----------------------------------------

{- | Run some tests with given tasty options; return success if all pass, 1 if
     some fail, 2 if setup failed -}
runTests_ ‚à∑ MonadIO Œº ‚áí TastyOpts ‚Üí Œº TastyRunResult
runTests_ (TastyOpts{..}) =
  liftIO $ case tryIngredients defaultIngredients optSet testTree of
    Just run_tests ‚Üí bool TestsFailed TestSuccess <$> run_tests
    Nothing        ‚Üí return TestRunFailure

{- | Run some tests, return exit code on failure (0 = success; 1 = some tests
     failed; 2 = failed to run). -}
runTests ‚à∑ MonadIO Œº ‚áí TastyOpts ‚Üí Œº ExitCode
runTests = (rrExitCode <$>) ‚àò runTests_

----------------------------------------

{- | Run a test tree, with default options. -}
runTestTree_ ‚à∑ MonadIO Œº ‚áí TestTree ‚Üí Œº TastyRunResult
runTestTree_ tree = runTests_ (TastyOpts tree mempty)

----------------------------------------

{- | Run a test tree, with default options.  See `runTests` for exit codes. -}
runTestTree ‚à∑ MonadIO Œº ‚áí TestTree ‚Üí Œº ExitCode
runTestTree tree = rrExitCode <$> runTestTree_ tree

----------------------------------------

{- | Run a test tree, with default options.  Designed for simple "main"
     invocations, e.g., as part of t/*.hs -}
runTestTree' ‚à∑ TestTree ‚Üí IO ()
runTestTree' = doMain' ‚àò runTestTree

----------------------------------------

{- | Run tests, with a given pattern (use "" to run everything). -}
runTestsP_ ‚à∑ (MonadIO Œº) ‚áí TestTree ‚Üí String ‚Üí Œº TastyRunResult
runTestsP_ ts "" =
  runTests_ (TastyOpts ts mempty)
runTestsP_ ts pat =
  case parseTestPattern $ toString pat of
    Just p  ‚Üí runTests_ (TastyOpts ts (singleOption p))
    Nothing ‚Üí return TestSuccess

----------------------------------------

{- | Run tests, with a given pattern (use "" to run everything). -}
runTestsP ‚à∑ (MonadIO Œº) ‚áí TestTree ‚Üí String ‚Üí Œº ExitCode
runTestsP ts pat = rrExitCode <$> runTestsP_ ts pat

----------------------------------------

runTestsReplay_ ‚à∑ TestTree ‚Üí String ‚Üí Natural ‚Üí IO TastyRunResult
runTestsReplay_ ts s r = do
  let replayO ‚à∑ Natural ‚Üí OptionSet
      replayO = singleOption ‚àò QuickCheckReplay ‚àò Just ‚àò fromIntegral
      tryOpt ‚à∑ TestPattern ‚Üí TestTree ‚Üí Maybe (IO Bool)
      tryOpt p = tryIngredients defaultIngredients $
                     singleOption p ‚äï replayO r

  case parseTestPattern s of
    Just p  ‚Üí fromMaybe (return TestRunFailure) $
                fmap (bool TestsFailed TestSuccess) <$> tryOpt p ts
    Nothing ‚Üí return TestRunFailure

{- | Run some tests (matching a pattern) with a replay code.  Use "" to run
     all tests -}
runTestsReplay ‚à∑ TestTree ‚Üí String ‚Üí Natural ‚Üí IO ExitCode
runTestsReplay ts s r = rrExitCode <$> runTestsReplay_ ts s r

----------------------------------------

-- | provide an OptParse-Applicative Parser for tasty options (to allow for
--   integration of tasty testing & options into an executable)
optParser ‚à∑ TestTree ‚Üí Parser TastyOpts
optParser testTree =
  TastyOpts testTree <$> suiteOptionParser defaultIngredients testTree

-- | alternate name for client convenience
tastyOptParser ‚à∑ TestTree ‚Üí Parser TastyOpts
tastyOptParser = optParser

----------------------------------------

{- | Wrapper for tests as main, e.g., in t/*.hs . -}
mainTests ‚à∑ MonadIO Œº ‚áí String ‚Üí TestTree ‚Üí Œº ()
mainTests desc ts = do
  tastyOpts ‚Üê liftIO $
              customExecParser (prefs showHelpOnError) $
                info (helper <*> tastyOptParser ts)
                     (fullDesc ‚äï progDesc desc ‚äï failureCode 254)

  Exited ‚Üê runTests tastyOpts >>= exitWith
  return ()

----------------------------------------

assertCmp' ‚à∑ HasCallStack ‚áí
             (Œ± ‚Üí Text) ‚Üí (Œ≤ ‚Üí Text) ‚Üí (Œ± ‚Üí Œ≤ ‚Üí ùîπ) ‚Üí Œ± ‚Üí Maybe Œ≤ ‚Üí Assertion
assertCmp' toTa _ _ expected Nothing =
       assertFailure ("expected: " ‚äï toString (toTa expected)
                                   ‚äï "\nbut got Nothing")
assertCmp' toTa toTb cmp expected (Just got) =
  let toSa = toString ‚àò toTa
      toSb = toString ‚àò toTb
   in -- equalize prefix lengths to make it easier to diff strings, etc.
       assertBool ("expected: " ‚äï toSa expected ‚äï "\nbut got : " ‚äï toSb got)
                  (cmp expected got)

{- | Compare two lists for compatibility, with customized, itemized testing.
     We take the inputs as IO to allow for, well, IO.
 -}
assertListCmpIO ‚à∑ (Foldable œà, Foldable œÜ, Printable œÉ, HasCallStack) ‚áí
                    (Œ± ‚Üí Text) ‚Üí (Œ≤ ‚Üí Text) ‚Üí (Œ± ‚Üí Œ≤ ‚Üí ùîπ) ‚Üí œÉ ‚Üí œà Œ± ‚Üí IO (œÜ Œ≤)
                  ‚Üí TestTree
assertListCmpIO toTa toTb cmp name (toList ‚Üí expect) (fmap toList ‚Üí got) =
  let lCheck e g =
        assertBool ("length " ‚äï show g ‚äï " did not match expected " ‚äï show e)
                   (e ‚â° g)
      lengthCheck e g = lCheck (length e) (length g)
      assertItem (i,e) =
        testCase (show i)
                 (got ‚â´ \ g ‚Üí assertCmp' toTa toTb cmp e (atMay g i))

   in testGroup (toString name) $
          testCase "count" (got ‚â´ lengthCheck expect)
        : (assertItem ‚ä≥ zip [0..] expect)

{- | Compare two lists for equality, with itemized testing and IO. -}
assertListEqIO' ‚à∑ (Foldable œà, Foldable œÜ, Eq Œ±, Printable œÉ, HasCallStack) ‚áí
                  (Œ± ‚Üí Text) ‚Üí œÉ ‚Üí œà Œ± ‚Üí IO (œÜ Œ±) ‚Üí TestTree
assertListEqIO' toT = assertListCmpIO toT toT (‚â°)

assertListEqIO ‚à∑ (Foldable œà, Foldable œÜ, Eq Œ±, Printable Œ±, HasCallStack) ‚áí
                Text ‚Üí œà Œ± ‚Üí IO (œÜ Œ±) ‚Üí TestTree
assertListEqIO = assertListEqIO' toText

--------------------

{- | Compare two lists for compatibility, with itemized testing. -}
assertListCmp ‚à∑ (Foldable œà, Foldable œÜ, Printable œÉ, HasCallStack) ‚áí
                  (Œ± ‚Üí Text) ‚Üí (Œ≤ ‚Üí Text) ‚Üí (Œ± ‚Üí Œ≤ ‚Üí ùîπ) ‚Üí œÉ ‚Üí œà Œ± ‚Üí œÜ Œ≤
                 ‚Üí TestTree
assertListCmp toTa toTb cmp name exp got =
  assertListCmpIO toTa toTb cmp name exp (return got)

--------------------

{- | Compare two lists for equality, with itemized testing. -}
assertListEq ‚à∑ (Eq Œ±, Printable Œ±, Foldable œà, Foldable œÜ, HasCallStack) ‚áí
               Text ‚Üí œà Œ± ‚Üí œÜ Œ± ‚Üí TestTree
assertListEq name expect got = assertListEqIO name expect (return got)

--------------------

assertListEqTests ‚à∑ TestTree
assertListEqTests =
  assertListEq "listTest" [ "foo", "bar", "baz" ‚à∑ String ]
                          [ "foo", "bar", "baz" ]

assertListEqTestsF ‚à∑ TestTree
assertListEqTestsF =
  testGroup "assertListEq fail" $
    [ assertListEq "listTest<" [ "foo", "bar" ]
                               [ "foo", "bar", "baz" ‚à∑ Text ]
    , assertListEq "listTest>" [ "foo", "bar", "baz" ]
                               [ "foo", "bar" ‚à∑ Text ]
    , assertListEq "listTest!" [ "foo", "bar", "baz" ]
                               [ "foo", "rab", "baz" ‚à∑ String ]
    ]

----------------------------------------

-- | like `assertListEq`, but using Show rather than Printable
assertListEqS ‚à∑ (Foldable œà, Foldable œÜ, Eq Œ±, Show Œ±) ‚áí
                 String ‚Üí œà Œ± ‚Üí œÜ Œ± ‚Üí [TestTree]
assertListEqS = assertListEq' (pack ‚àò show)

----------------------------------------

-- | compare two lists for equality, with itemized testing
assertListEq' ‚à∑ (Foldable œà, Foldable œÜ, Eq Œ±) ‚áí
                (Œ± ‚Üí Text) ‚Üí String ‚Üí œà Œ± ‚Üí œÜ Œ± ‚Üí [TestTree]
assertListEq' toT name gotL expectL =
  let got    = toList gotL
      expect = toList expectL
      lCheck g e =
        assertBool ("length " ‚äï show g ‚äï " did not match expected " ‚äï show e)
                   (e ‚â° g)
      lengthCheck g e = lCheck (length g) (length e)
      assertItem gt exp i = let nm = name <> ": " <> show i
                             in testCase nm $ assertEq' toT gt exp
   in   testCase (name <> ": count") (lengthCheck got expect)
      : zipWith3 assertItem got expect [1 ‚à∑ Int ..]

----------------------------------------

-- | like `assertListEq`, but takes an Either which must be a Right
assertListEqR ‚à∑ (Foldable œà, Foldable œÜ, Eq Œ±, Printable Œ±, Show Œµ) ‚áí
                 String ‚Üí Either Œµ (œà Œ±) ‚Üí (œÜ Œ±) ‚Üí [TestTree]
assertListEqR = assertListEqR' toText

--------------------

assertListEqRTests ‚à∑ TestTree
assertListEqRTests =
  testGroup "assertListEq" $
    assertListEqR "listTestR"
                  (Right [ "foo", "bar", "baz" ] ‚à∑ Either String [String])
                  [ "foo", "bar", "baz" ]

assertListEqRTestsF ‚à∑ TestTree -- tests that should fail!
assertListEqRTestsF =
  testGroup "assertListEq fail" $
    assertListEqR "listTestR" (Left "weebles" ‚à∑ Either String [String])
                              [ "foo", "bar", "baz" ]

----------------------------------------

-- | like `assertListEq`, but takes an Either which must be a Right
assertListEqR' ‚à∑ (Foldable œà, Foldable œÜ, Eq Œ±, Show Œµ) ‚áí
                 (Œ± ‚Üí Text) ‚Üí String ‚Üí Either Œµ (œà Œ±) ‚Üí œÜ Œ± ‚Üí [TestTree]
assertListEqR' toT name got expect =
  case got of
    Left  e ‚Üí [testCase name (assertFailure ("got a Left: " <> show e))]
    Right r ‚Üí assertListEq' toT name r expect

----------------------------------------

assertListEqRS ‚à∑ (Foldable œà, Foldable œÜ, Eq Œ±, Show Œµ, Show Œ±) ‚áí
                  String ‚Üí Either Œµ (œà Œ±) ‚Üí œÜ Œ± ‚Üí [TestTree]
assertListEqRS = assertListEqR' (pack ‚àò show)

----------------------------------------

-- | test that we got a 'Right' value, satisfying the given assertion
assertRight ‚à∑ Show Œ≥ ‚áí (œÅ ‚Üí Assertion) ‚Üí Either Œ≥ œÅ ‚Üí Assertion
assertRight assertion got =
  case got of Right g ‚Üí assertion g
              Left  e ‚Üí assertFailure (show e)

--------------------

assertRightTests ‚à∑ TestTree
assertRightTests =
  testGroup "assertRight"
    [ testCase "right" $
      assertRight ((@?= 4) ‚àò length) (Right "good" ‚à∑ Either Int String)
    ]

assertRightTestsF0 ‚à∑ TestTree
assertRightTestsF0 =
  testGroup "assertRight fail (0)"
    [ testCase "right" $
      assertRight ((@?= 4) ‚àò length) (Left 7 ‚à∑ Either Int String)
    ]

assertRightTestsF1 ‚à∑ TestTree
assertRightTestsF1 =
  testGroup "assertRight"
    [ testCase "right fail (1)" $
      assertRight ((@?= 4) ‚àò length) (Right "bad" ‚à∑ Either Int String)
    ]


----------------------------------------

-- | test that we got a 'Left' value, satisfying the given assertion
assertLeft ‚à∑ Show œÅ ‚áí (Œ≥ ‚Üí Assertion) ‚Üí Either Œ≥ œÅ ‚Üí Assertion
assertLeft assertion got =
  case got of Right r ‚Üí assertFailure (show r)
              Left  l ‚Üí assertion l

----------------------------------------

{- | Check that a value is a Left, but nothing more -}
assertIsLeft ‚à∑ Show Œ≤ ‚áí Either Œ± Œ≤ ‚Üí Assertion
assertIsLeft = assertLeft (const $ assertSuccess "is Left")

----------------------------------------


{- | Check that any exception is thrown.  Any exception will cause the test
     to pass; no exception will cause it to fail.
 -}
assertAnyException ‚à∑ (NFData Œ±) ‚áí String ‚Üí Œ± ‚Üí IO ()
assertAnyException n = assertException n (const True)

assertAnyExceptionIO ‚à∑ (NFData Œ±) ‚áí String ‚Üí IO Œ± ‚Üí IO ()
assertAnyExceptionIO n = assertExceptionIO n (const True)

{- | Check that an exception is thrown.  Any exception that is thrown is
     checked by the given predicate; the predicate pass to indicate that the
     exception is as desired; and thus a @False@ will cause a test failure.  The
     test itself, if it returns a value (without an exception) will pass; but
     note that being IO, it can itself run tests...
 -}
assertException ‚à∑ (NFData Œ±) ‚áí String ‚Üí (SomeException ‚Üí Bool) ‚Üí Œ± ‚Üí IO ()
assertException n p v = assertExceptionIO n p (return v)

assertExceptionIO ‚à∑ (NFData Œ±) ‚áí String ‚Üí (SomeException ‚Üí Bool) ‚Üí IO Œ± ‚Üí IO ()
assertExceptionIO n p io =
  handle (return ‚àò Left) (Right <$> (io >>= evaluate ‚àò force)) >>= \ case
    Left e ‚Üí assertBool n (p e)
    Right _ ‚Üí assertFailure ("no exception thrown: " ‚äï n)

----------------------------------------

-- | test that we got an IOException (note, not just any Exception), and that
--   it matches a given predicate
assertIOException ‚à∑ (AsIOError Œµ, Show œÅ) ‚áí (Œµ ‚Üí Assertion) ‚Üí IO œÅ ‚Üí Assertion
assertIOException p io = (runExceptT $ asIOError io) >>= assertLeft p

assertIOException' ‚à∑ (Show œÅ) ‚áí (IOError ‚Üí Assertion) ‚Üí IO œÅ ‚Üí Assertion
assertIOException' = assertIOException

----------------------------------------

assertEq' ‚à∑ (Eq t) ‚áí (t ‚Üí Text) ‚Üí t ‚Üí t ‚Üí Assertion
assertEq' toT e e' =
  let toS = toString ‚àò toT
   in assertBool ("expected: " ‚äï toS e' ‚äï "\nbut got: " ‚äï toS e) (e ‚â° e')

-- | a bit like `assertEqual`, but generates its own message based on `toText`
--   of the arguments (because that may be more readable than show).

assertEq ‚à∑ (Eq t, Printable t) ‚áí t ‚Üí t ‚Üí Assertion
assertEq = assertEq' toText

-- | infix version of `assertEq` thus akin to `@=?` (but using `toText` rather
--   than `show`)

(#=?) ‚à∑ (Eq t, Printable t) ‚áí t ‚Üí t ‚Üí Assertion
(#=?) = flip assertEq

-- | infix version of `assertEq` thus akin to `@?=` (but using `toText` rather
--   than `show`)
(#?=) ‚à∑ (Eq t, Printable t) ‚áí t ‚Üí t ‚Üí Assertion
(#?=) = assertEq

--------------------

assertEqTests ‚à∑ TestTree
assertEqTests =
  testGroup "assertEq" [ testCase "foo" $ "foo" #=? ("foo" ‚à∑ String) ]

assertEqTestsF ‚à∑ TestTree
assertEqTestsF =
  testGroup "assertEqF" [ testCase "foo" $ "foo" #=? ("bar" ‚à∑ Text) ]

----------------------------------------

{- | Construct a test group, wherein each test is passed a value that has been
     pre-initialized in some IO.  Note that the IO is not run for each test, it
     is run no more than once (and that, of course, only if the tests are run).
 -}
ioTests ‚à∑ TestName ‚Üí [(TestName, Œ± ‚Üí Assertion)] ‚Üí IO Œ± ‚Üí TestTree
ioTests name ts ioa =
  testGroup name $ (\ (tname,t) ‚Üí testCase tname $ ioa >>= t) <$> ts

----------------------------------------

{- | like `withResource`, but with a no-op release resource -}
withResource' ‚à∑ IO Œ± ‚Üí (IO Œ± ‚Üí TestTree) ‚Üí TestTree
withResource' = flip withResource (const $ return ())

----------------------------------------

withResource2 ‚à∑ IO Œ± ‚Üí (Œ± ‚Üí IO()) ‚Üí IO Œ≤ ‚Üí (Œ≤ ‚Üí IO ()) ‚Üí (IO Œ± ‚Üí IO Œ≤ ‚ÜíTestTree)
              ‚Üí TestTree
withResource2 gain lose gain' lose' ts =
  withResource gain lose (\ x ‚Üí withResource gain' lose' (\ x' ‚Üí ts x x'))

----------------------------------------

withResource2' ‚à∑ IO Œ± ‚Üí IO Œ≤ ‚Üí (IO Œ± ‚Üí IO Œ≤ ‚Üí TestTree)
              ‚Üí TestTree
withResource2' gain gain' ts =
  withResource' gain (\ x ‚Üí withResource' gain' (\ x' ‚Üí ts x x'))

----------------------------------------

{- | For complex tests that need an IO setup; where having acquired the
     resource, the setup may fail; regular `withResource` doesn't clean that up
     (since the acquire step throws an exception, the return value is never seen
     and so cannot be passed to the release); this version splits acquisition
     and setup.

     If acquisition fails, there should be nothing to release.
     But if setup fails, the release is called (though of course no tests are
     run).
     If the setup succeeds, tests are run, and cleanup is called.
 -}
withResourceCleanup ‚à∑ IO Œ± ‚Üí (Œ± ‚Üí IO ()) ‚Üí (Œ± ‚Üí IO ()) ‚Üí (IO Œ± ‚Üí TestTree)
                    ‚Üí TestTree
withResourceCleanup acquire setup release test =
  let -- safely acquire and run setup; if setup throws an IOException, release
      -- acquireAndSetup ‚à∑ IO Œ±
      acquireAndSetup = acquire ‚â´ \ resource ‚Üí do
        onException (setup resource) (release resource)
        return resource
   in withResource acquireAndSetup release test

-- Common Properties ---------------------------------------

newtype P Œ± = P Œ±
  deriving Eq

instance Printable Œ± ‚áí Printable (P (Parsed Œ±)) where
  print (P (Parsed a))       = P.string (toString a)
  print (P (Malformed [] s)) =
    let quote t = "'" <> t <> "'"
     in P.string $ "MALFORMED: " <> quote s
  print (P (Malformed ss s)) =
    let quote     t  = "'" <> t <> "'"
        bracketsp t  = "[ " <> t <> " ]"
        list    ts = bracketsp $ intercalate ", " (quote <$> ts)
     in P.string $ "MALFORMED: " <> quote s <> " " <> list ss

propInvertibleString ‚à∑ (Eq Œ±, Printable Œ±, Textual Œ±) ‚áí Œ± ‚Üí Property
propInvertibleString d = P (parseString (toString d)) ‚â£ P (Parsed d)

propInvertibleText ‚à∑ (Eq Œ±, Printable Œ±, Textual Œ±) ‚áí Œ± ‚Üí Property
propInvertibleText d = P (parseText (toText d)) ‚â£ P (Parsed d)

propInvertibleUtf8 ‚à∑ (Eq Œ±, Printable Œ±, Textual Œ±) ‚áí Œ± ‚Üí Property
propInvertibleUtf8 d = P (parseUtf8 (toUtf8 d)) ‚â£ P (Parsed d)

propAssociative ‚à∑ (Eq Œ±, Printable Œ±) ‚áí (Œ± ‚Üí Œ± ‚Üí Œ±) ‚Üí Œ± ‚Üí Œ± ‚Üí Œ± ‚Üí Property
propAssociative f a b c = f a (f b c)  ‚â£ f (f a b) c

--------------------------------------------------------------------------------
--                                   tests                                    --
--------------------------------------------------------------------------------

_test0 ‚à∑ IO TastyRunResult
_test0 = -- test that runTestsP correctly selects only the working tests
         runTestsP_ tests "simpleTest/t"

_test1 ‚à∑ IO TastyRunResult
_test1 = runTestsP_ tests "normal"

_test ‚à∑ IO ()
_test = do
  TestSuccess ‚Üê _test0
  TestSuccess ‚Üê _test1
--  TestSuccess ‚Üê runTestTree _failTests
  return ()

_ftest ‚à∑ IO ()
_ftest = do
  TestSuccess ‚Üê runTestTree_ _failTests
  return ()

----------------------------------------

{- | Simple tests, with a failure, to allow for a pattern to select only the
     passing tests.
-}

mkSimpleTests ‚à∑ Foldable t ‚áí
                t ((String ‚Üí Int ‚Üí Int ‚Üí TestTree) ‚Üí [TestTree]) ‚Üí TestTree
mkSimpleTests ts =
  let tC ‚à∑ String ‚Üí Int ‚Üí Int ‚Üí TestTree
      tC name got expect = testCase name $ got @?= expect
   in testGroup "simple" $ concatMap ($ tC) ts

----------------------------------------

simpleTestsS ‚à∑ (String ‚Üí Int ‚Üí Int ‚Üí TestTree) ‚Üí [TestTree]
simpleTestsS tC = [ tC "two" 2 2, tC "three" 3 3 ]

----------------------------------------

simpleTestsF ‚à∑ (String ‚Üí Int ‚Üí Int ‚Üí TestTree) ‚Üí [TestTree]
simpleTestsF tC = [ tC "one" 1 2 {- deliberate fail -} ]



----------------------------------------

tests ‚à∑ TestTree
tests = testGroup "tests" [ unitTests, pTests, propTests ]

unitTests ‚à∑ TestTree
unitTests = testGroup "unitTests" [ hunitGroup ]

hunitGroup ‚à∑ TestTree
hunitGroup = testGroup "hunit" [ mkSimpleTests [ simpleTestsS ]
                               , normalTests ]

normalTests ‚à∑ TestTree
normalTests = testGroup "normal" [ assertEqTests
                                 , assertListEqRTests
                                 , assertListEqTests
                                 , assertRightTests
                                 ]

_failTests ‚à∑ TestTree
_failTests =
  let failIt name tree = testCase name $ runTestTree_ tree >>= (@?= TestsFailed)
   in testGroup "fail"
                 [ failIt "simpleTests"         (mkSimpleTests [simpleTestsF])
                 , failIt "assertEq"            assertEqTestsF
                 , failIt "assertRightTestsF0"  assertRightTestsF0
                 , failIt "assertRightTestsF1"  assertRightTestsF1
                 , failIt "assertListEqTestsF"  assertListEqTestsF
                 , failIt "assertListEqRTestsF" assertListEqRTestsF
                 ]

pTests ‚à∑ TestTree
pTests =
  testGroup "P.normal"
            [ testCase "malformed (0)" $
                  "MALFORMED: 'foo'"
                ‚âü toString (P $ Malformed @String [] "foo")
            , testCase "malformed (1)" $
                  "MALFORMED: 'foo' [ 'a', 'b', 'c' ]"
                ‚âü toString (P $ Malformed @String ["a","b","c"] "foo")
            , testCase "parsed" $ "bar" ‚âü toString (P $ Parsed @String "bar")
            ]

propTests ‚à∑ TestTree
propTests =
  testGroup "prop.normal"
            [ testGroup "Rational - Invertible"
                        [ testProperty "String" (propInvertibleString @Rational)
                        , testProperty "Text"   (propInvertibleText   @Rational)
                        , testProperty "Utf8"   (propInvertibleUtf8   @Rational)
                        ]
            , testGroup "Rational - Associative"
                        [ testProperty "*" (propAssociative @Rational (*))]
            ]

-- that's all, folks! ----------------------------------------------------------
